---
title: "QualMiner: Exploring qualitative indicators via text mining methods"
date: "`r Sys.Date()`"
output:
  html_document:
    includes:
      in_header: assets/header.html
      after_body: assets/footer.html
    theme: cosmo
    css: assets/style.css
    highlight: pygments
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

<script src="assets/script.js"></script>

```{r setup, include=FALSE}
## `conflicted` strategy to avoid namespace clashes.
## See https://github.com/r-lib/conflicted
library(conflicted)
## Header file
source(file.path("..", "R", "global-header.R"))
## Analysis related calls
source(file.path("..", "R", "analysis-methods.R"))
source(file.path("..", "R", "analysis-helpers.R"))
## Libraries
library(tidyverse)
library(tidytext)
library(tsibble)
library(scales)
library(treemapify)
library(gt)
## Pre-set the bw theme for ggplot (for plots don't use any custom theme).
ggplot2::theme_set(ggplot2::theme_bw())
## knitr options
knitr::opts_chunk$set(echo = FALSE, paged.print = FALSE, cache = TRUE)
## read Data from disk:
form.table <- jsonlite::fromJSON(file.path("..", TEXT.DATA.PATH))
## (force it to be a tibble):
form.table <- tibble::as_tibble(form.table)
```

# Introduction

```{r child = 'analysis/introduction.Rmd', eval=FALSE}
```

```{r FOR-INTERNAL-USE, include=FALSE}
## unique record ids
unique(form.table$recordId)

## record ids and unique fields
form.table %>% 
  group_by(recordId) %>% 
  summarize(len = length(recordId)) %>% 
  arrange(desc(len))

## Code names per record
code.nms <- form.table %>% group_by(recordId) %>% select(recordId, code) %>% 
  summarize(names = list(code))
head(code.nms$names)

## Do all records have "Socio" field?
socio.fields <- sapply(seq_along(code.nms$names), function(i) "Socio" %in% code.nms$names[[i]])
all(socio.fields)

## Do all records have "direct_indirect" field?
direct_indirect.fields <- sapply(seq_along(code.nms$names), function(i) "direct_indirect" %in% code.nms$names[[i]])
all(direct_indirect.fields)
```

### Partners

They are two types of partners in the database:

+ Reporting partners: Higher level of partners reporting directly in ActivityInfo.

+ Implementing partners: Partners reporting through a reporting partner.

```{r, include=FALSE}
partners <- form.table %>% 
  group_by(recordId) %>% 
  dplyr::filter(code == "Socio") %>% 
  mutate(response = if_else(response == "FALSE", NA_character_, response)) %>% # recode FALSE
  select(recordId, partnerName, response, canton, province) %>% 
  rename(subPartnerName = response) %>% 
  mutate(subPartnerName = if_else(is.na(subPartnerName), partnerName, subPartnerName))
ppartners <- partners %>%
  group_by(partnerName) %>%
  count(partnerName, name = "freq", sort = TRUE) %>%
  ungroup() %>%
  mutate(prop = round(freq / sum(freq), 3))
```

The table below shows the count of reporting partner per each record:

+ **`r ppartners[1,"partnerName",drop=T]`** has `r xfun::n2w(ppartners[1,"freq",drop=T])`
records, 
which is `r scales::percent(ppartners[1,"prop",drop=T])`
of the total records.

+ Second, 
**`r ppartners[2,"partnerName",drop=T]`** has `r xfun::n2w(ppartners[2,"freq",drop=T])`
records, 
which is `r scales::percent(ppartners[2,"prop",drop=T])`
of the total records.

+ The most difference between percentages of the partners 
**`r ppartners[1,"partnerName",drop=T]`**
and
**`r ppartners[2,"partnerName",drop=T]`**
is
*`r paste0(floor(convolve((ppartners[1,"prop",drop=T]-ppartners[2,"prop",drop=T]), 100)), '%')`*.

<br>

```{r}
ppartners %>%
  rename(
    `Reporting partner` = partnerName,
    `Frequency` = freq,
    `Relative frequency` = prop
  ) %>% 
  gt() %>% 
  gt_condensed_style()
```

```{r, include=FALSE}
PartnerSubPropFreq <- partners %>% 
  group_by(partnerName, subPartnerName) %>% 
  count(partnerName, subPartnerName, name = "freq", sort = TRUE) %>% 
  summarize(freq = sum(freq)) %>% 
  mutate(prop = round(freq/sum(freq), 3)) %>% 
  mutate(percent = paste0(floor(100 * freq/sum(freq)), "%"))
```

```{r, include=FALSE}
acnur.hias.part <- PartnerSubPropFreq %>% 
  dplyr::filter(partnerName %in% "ACNUR", subPartnerName %in% "HIAS")
```

The table below shows the proportion of records entered by
partners and sub-partners.

+ *`r acnur.hias.part[,"freq",drop=T]`* out of 
*`r sum(PartnerSubPropFreq %>% dplyr::filter(partnerName %in% "ACNUR") %>% pull(freq))`* 
total responses of **ACNUR** is actually coming from **HIAS**.

+ **UNICEF** has more diversed partners in terms of reporting.
*`r PartnerSubPropFreq%>%dplyr::filter(partnerName%in% "UNICEF", subPartnerName %in% "HIAS")%>%pull(percent)`*
of responses of **UNICEF** comes from **HIAS**.
*`r PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "UNICEF", subPartnerName %in% "UNICEF")%>% pull(percent)`*
of reporting comes from the **UNICEF** itself.

+ Under **PMA**, there are *`r nrow(PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "PMA"))`* sub-partners. **HIAS** reports *`r PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "PMA", subPartnerName %in% "HIAS")%>%pull("percent")`* of these records.

Those are the total numbers of reporting in all database, the numbers are not
specific to the narratives (multi-line text fields). In the next section, we
count the number of reportings done only in the narrative sections.

<br>

```{r, echo=FALSE}
## Used parse & eval because of this issue: 
## https://github.com/rstudio/gt/issues/308
pspf.bold_groups <- glue::glue_collapse(glue::glue('
  tab_style(
    locations = cells_group(groups = "{x}"),
    style = cells_styles(text_weight = "bold")
  )
  ',
  x = unique(PartnerSubPropFreq$partnerName)
  ),
  sep = " %>%\n")
pspf.tbl <- PartnerSubPropFreq %>% 
  group_by(subPartnerName) %>% 
  arrange(desc(freq)) %>% 
  group_by(partnerName) %>% 
  rename(
    `Reporting partner` = partnerName,
    `Implementing partner` = subPartnerName,
    `Frequency` = freq,
    `Relative frequency` = prop
  ) %>% 
  select(-percent)
eval(parse(text=glue::glue('
pspf.tbl %>%
  gt() %>% 
  gt_condensed_style() %>% 
  {bolds}
', bolds = pspf.bold_groups)))
```

<hr>

```{r child = 'analysis/tabset-partner.Rmd', eval=TRUE}
```

## Narrative data

In this section, we focus on a subset of the reports, which do particularly have
the multi-text fields, called "Narrative data" in ActivityInfo terms. Plain
saying that narrative data is multi-line text fields allowing users to enter
long texts.

```{r data-source-preparation}
narratives <- form.table %>%
  dplyr::filter(!is.na(response) & type == "NARRATIVE") %>%
  inner_join(
    select(partners, recordId, partnerName, subPartnerName),
    by = c("partnerName", "recordId")
  ) %>%
  select(
    "folderName",
    "formName",
    "Month",
    "question",
    "response",
    "description",
    "partnerName",
    "subPartnerName",
    "province",
    "canton"
  )
```

### The number of Reporting Partners and Implementing Partners recording multi-line narrative textual data

```{r}
narratives.part.count <- narratives %>% 
  group_by(partnerName, subPartnerName) %>% 
  count(partnerName, subPartnerName, name = "freq", sort=TRUE) %>% 
  summarize(freq = sum(freq)) %>% 
  mutate(prop = round(freq/sum(freq), 3)) %>% 
  mutate(percent = paste0(floor(100 * freq/sum(freq)), "%"))

## partners having multiple sub-partners
narratives.part.count.with.subPartners <- narratives.part.count %>% 
  dplyr::filter(prop != 1) %>% 
  ungroup()

## partners do not have any sub-partners reporting via them.
narratives.part.count.without.subPartners <- narratives.part.count %>% 
  dplyr::filter(prop == 1) %>% 
  ungroup()
```

As we have seen previously, Not all Reporting and Implementing Partners record
multi-line narrative textual data. For instance, the partner **PMA** has lots of
Implementing Partners reporting for the different data types (as seen in above)
but there are no narratives from them.

```{r, warning=FALSE, fig.width=7, fig.height=5}
## grouped facet wraps. Source:
## https://stackoverflow.com/questions/14840542/place-a-legend-for-each-facet-wrap-grid-in-ggplot2

plot_partners_splitted <- split(
  x = narratives.part.count.with.subPartners, 
  f = narratives.part.count.with.subPartners$partnerName
)

## bring ACNUR and UNICEF plots to the front:
plot_partners_splitted_front <- plot_partners_splitted[c(
  c("ACNUR", "UNICEF"),
  setdiff(names(plot_partners_splitted), c("ACNUR", "UNICEF"))
)]

plot_partners_list <- lapply(seq_along(plot_partners_splitted_front), function(i) {
  ggplot(plot_partners_splitted_front[[i]], aes(x = partnerName, y = prop)) +
    geom_bar(aes(fill = reorder(subPartnerName,-prop)), position = "dodge", stat =
               "identity", color = "black") +
    facet_wrap(~ partnerName, scales = "free") +
    geom_label(
      aes(
        label = percent,
        group = reorder(subPartnerName,-prop),
        vjust = 0.65
      ),
      position = position_dodge(width = 1),
      label.size = 0.35
    ) +
    ylim(0, 1) + 
    xlab(NULL) +
    ylab(NULL) +
    theme_ecuador1(border = TRUE) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      legend.title = element_blank(),
      legend.position = "bottom"
    ) +
    scale_fill_brewer(palette = "Set2")
})

## "cowplot" is civilized version of 'gridExtra'.
do.call(cowplot::plot_grid, plot_partners_list)
```

`TODO`
In terms of narrative data,

The partners X and Y is like that.
The rest of the main partners, namely ...
do not have any subpartners reporting by them.

+ The partners do not have any sub-partners reporting via them: 
*`r paste(narratives.part.count.without.subPartners$partnerName, collapse = ", ")`*.

***

### The number cantons and provinces recording narrative data

```{r, include = FALSE}
locations <- narratives %>% 
  count(province, canton, name = "freq") %>%
  group_by(province, canton) %>% 
  summarize(freq = sum(freq)) %>%
  mutate(canton.prop = round(freq/sum(freq), 3)) %>% 
  mutate(canton.percent = paste0(floor(100 * freq/sum(freq)), "%")) %>% 
  ungroup() %>% 
  mutate(province.prop = round(freq/sum(freq), 3)) %>% 
  mutate(province.percent = paste0(floor(100 * freq/sum(freq)), "%")) %>% 
  arrange(desc(freq))
```

```{r canton-locations-tbl}
## Used parse & eval because of this issue: 
## https://github.com/rstudio/gt/issues/308
lcts.bold_groups <- glue::glue_collapse(glue::glue('
  tab_style(
    locations = cells_group(groups = "{x}"),
    style = cells_styles(text_weight = "bold")
  )
  ', 
  x = unique(locations$province)
),
sep = " %>%\n")
lcts.tbl <- locations %>%
  select(province, canton, freq, canton.prop, province.prop) %>%
  group_by(province) %>% 
  arrange(desc(freq)) %>% 
  rename(
    `Canton` = canton,
    `Frequency` = freq,
    `Relative frequency (canton)` = canton.prop,
    `Relative frequency (province)` = province.prop
  )
eval(parse(text=glue::glue('
lcts.tbl %>% 
  gt() %>% 
  tab_header(
    title = "Canton and provinces",
    subtitle = "The number of reports in the multi-text (narrative) fields"
  ) %>% 
  gt_condensed_style() %>% 
  {bolds}
', bolds = lcts.bold_groups)))
```

<br>
<br>

Treemap plot showing canton and province reporting frequencies.

```{r treemap, fig.width=9, fig.height=6}
tree.colors <-c(
  RColorBrewer::brewer.pal(name = "Dark2", n = 8),
  RColorBrewer::brewer.pal(name = "Set2", n = 8)
)
ggplot(locations,
       aes(
         area = province.prop,
         fill = province,
         #label = sprintf("%s (%s)", canton, canton.freq),
         label = canton,
         subgroup = sprintf("%s\n(%s)", province, province.percent)
       )) +
  geom_treemap()+
  geom_treemap_subgroup_border(color="gray25")+
  geom_treemap_text(colour = "black", place = "centre", alpha = 0.45, reflow = TRUE, min.size = 0)+
  geom_treemap_subgroup_text(grow = TRUE, colour="white", alpha = 0.85, place = "topleft", fontface = "italic")+
  theme(legend.position = "none") +
  scale_fill_manual(values = tree.colors)
```

# Analysis

## Label forms recode table

First of all, we shorten the names and therefore re code form topics because they appear to be
too long and disarray the plots. The *re coded table* below provides a  look up
for form labels and their abbreviations:

```{r recode-table}
narratives <- narratives %>% 
  mutate(
    labelFormsRecode = recode(
      labelForms,
      "Agua, saneamiento e higiene" = "Agua",
      "Alojamiento Temporal" = "Alojamiento",
      "Necesidades básicas/Otro" = "Necesidades",
      "Manejo de la información y entrega directa de la información a la población" = "Población",
      "Manejo de la información para socios y análisis de las necesidades" = "Socios",
      "Protección_VBG" = "VBG",
      "Trata_y_tráfico" = "Tráfico",
      "Acceso_a_educación" = "Educación",
      "Acceso a vivienda y hábitat dignos en comunidades receptoras" = "Hábitat",
      "Medios de vida y formación técnico-profesional" = "Técnico",
      "Cohesión_social" = "SocialCohesión",
      "Apoyo Educacional a Comunidades Receptoras" = "Educacional",
      "Asistencia técnica para VBG-SSR" = "VBG_SSR",
      "Asistencia técnica para protección/gestión de fronteras" = "Fronteras",
      "Asistencia técnica para gestion de la informacion y coordinacion" = "Coordinacion",
      "Asistencia técnica para el sector laboral" = "SectorLaboral",
      "Asistencia técnica para protección" = "Protección",
      "Asistencia técnica para protección de la infancia" = "ProtecciónInfancia",
      "Protección_LGBTI" = "LGBTI"
    )
  )

recode_tbl <- narratives %>%
  select(labelFormsRecode, labelForms) %>% 
  distinct()

recode_tbl %>% 
  gt() %>% 
  gt_condensed_style() %>% 
  tab_footnote(
    footnote = md("*Recoding only some long label forms, shorter names can stay as such (e.g. 'Salud')*"),
    locations = cells_column_labels(
      columns = vars(labelFormsRecode)
    )
  )
```

## Response quality

Response quality means how much response the questions receive. The idea is to
find relations that affect the response quality to understand if they work or
not under some conditions.

*Research questions:*

+ What is the quality of textual responses in the narrative fields?

+ Is there any relationship between the word counts of response, question and
description fields?

+ What is the distribution between response word count and explanatory variables
such as the question, form topic, canton name, partner name, etc.

*Assumptions:*

+ Responses with a *larger word count* have more quality than the responses
with *smaller word count*.

In other words, we assume that *the more word the better is*. The limitations
are based on the unequal distribution of the data. The word count of responses
and questions can be related to other things, such as the questions require
short answers so then the responses tend to be shorter.

Additionally, we can have a cross-analysis to test these outcomes. It might be a
good idea to have a small subset of data and ask an expert to test the
assumptions qualitatively. For instance, we can take the first twenty responses
with the highest word count and the last twenty responses with the lowest word
count. We chose the extreme directions because they point out the greatest
differences which are easier to test assumptions.

### Word count 

One issue with the nature of the questions is that they are only unique in a
form. These questions can be distributed across multiple forms. The questions
sharing the same name will have different meanings. For instance, the question
"*Cualitativo*" from the form "*Salud*" should imply different thing than the
question "*Cualitativo*" from the form "*Protección_VBG*".

In order to solve this kind of problem:

+ We can combine question with the form and also its folder label. There we can
achieve a unique name for each question.

+ Another thing to resolve this would be doing analysis to move the analysis up
to form level. In this file, we did both, therefore the analysis shown as below:

Count of responses per topic/question:
```{r count-response}
narratives.wc <- narratives %>%
  mutate(.responseWordCount = word_count(response)) %>%
  mutate(.questionWordCount = word_count(question)) %>%
  group_by(labelForms) %>%
  select(
    labelForms, question, response, 
    .responseWordCount, .questionWordCount, 
    partnerName, canton,
    description, labelFormsRecode
  ) %>% 
  ungroup()

head(narratives.wc) %>% 
  mutate(response = strtrim(response, 15)) %>% 
  mutate(description = strtrim(description, 15)) %>% 
  gt() %>% 
  gt_condensed_style()
```

It's also a good practice to see the number of questions. For example, one
question has two responses, therefore they're short. Therefore, jittered points
are added to give a glance about the number of observations in the same plot.

```{r plot-topic-response-wc, fig.width=8, fig.height=8}
# TODO facet by labelFolder
narratives.wc %>%
  gather(variable, value, .responseWordCount, .questionWordCount) %>%
  ggplot(aes(labelFormsRecode, value, fill = variable)) +
  geom_boxplot(outlier.colour = "orange", outlier.shape = 1, outlier.alpha = 0.35) +
  coord_flip() +
  geom_jitter(alpha = 0.35) +
  labs(
    title = "Response and Question word counts per form topic",
    subtitle = "A box plot distribution",
    caption = "*Please refer to recode table for label forms"
  ) +
  theme_ecuador1() +
  theme(legend.position = "bottom")
```

In the plot above, the box plot of form topics and response word counts based on
the raw data, the outliers are shown in orange color. Outliers are the points
placed outside the whiskers, which is the long line, of the boxplot.

The response word count distribution per form topic categorized by partner name:

```{r plot-partner-response-wc, fig.width=10, fig.height=20}
narratives.wc %>%
  gather(variable, value, .responseWordCount) %>% 
  ggplot(aes(labelFormsRecode, value)) +
  geom_boxplot(outlier.colour = "orange", outlier.shape = 1, outlier.alpha = 0.35) +
  coord_flip() +
  geom_jitter(alpha = 0.35) +
  facet_wrap(partnerName ~ ., scales = "free", ncol = 2) +
  labs(
    title = "Word count of responses by form topics per partner",
    subtitle = "A box plot distribution",
    caption = "*Please refer to recode table for label forms"
  ) +
  theme_ecuador1(border = TRUE)
```

The response word count distribution per form topic categorized by canton name:

```{r plot-canton-response-wc, fig.width=10, fig.height=20}
narratives.wc %>%
  gather(variable, value, .responseWordCount) %>% 
  ggplot(aes(labelFormsRecode, value)) +
  geom_boxplot(outlier.colour = "orange", outlier.shape = 1, outlier.alpha = 0.35) +
  geom_jitter(alpha = 0.35) +
  coord_flip() +
  facet_wrap(~canton, scales = "free", ncol = 2) +
  labs(
    title = "Word count of responses by form topics per canton",
    subtitle = "A box plot distribution",
    caption = "*Please refer to recode table for label forms"
  ) +
  xlab(NULL) +
  ylab(NULL) +
  theme_ecuador1(border = TRUE) +
  theme(panel.spacing = unit(0, "lines"))
```

<br>

```{r, fig.width=7, fig.height=7}
lf <- narratives.wc %>% 
  group_by(labelFormsRecode) %>% 
  select(labelFormsRecode, .responseWordCount, .questionWordCount)
lf$labelFormsRecode <- as.factor(lf$labelFormsRecode)

## Make all data; gray background
lf_bg <- lf[, -1]

lf.xlab <- expression(paste("Word counts in ", italic("response"), " field"))
lf.ylab <- expression(paste("Word counts in ", italic("question"), " field"))
ggplot(lf, aes(x = .responseWordCount, y = .questionWordCount, color = labelFormsRecode)) +
  geom_point(data = lf_bg,
             colour = "grey",
             alpha = 0.2) + # 
  geom_point(size = 3L) + # actual points
  geom_point(shape = 21, color = "black", stroke = 0.2, size = 3L) + # for point borders
  facet_wrap( ~ labelFormsRecode) +
  theme_ecuador1(border = TRUE) +
  guides(color = FALSE) +
  labs(
    title = "Response and Question word counts per form topic",
    caption = "*Please refer to recode table for label forms"
  ) +
  xlab(lf.xlab) +
  ylab(lf.ylab)
```

<br>

*A caveat:* Reducing multiple values down to a single value should be avoided in
the early stages of the analysis because reducing hides a lot e.g. a bar chart
showing average the word count per partner. Some partners may write longer than
others, because:

1. They *actually* write longer than other partners.

2. The questions they answered require short answers.

### The Description field

Some questions have the description field giving extra details about the
questions.

Do some questions with the extra description field have better *response
quality* than the questions which do not have it?

Looking at the table containing form name, question, description and so on:

```{r, table1}
description.field.wc <- narratives.wc %>% 
  mutate(.hasDescription = ifelse(is.na(description), FALSE, TRUE)) %>% 
  mutate(.descriptionWordCount = word_count(description)) %>%
  select(labelForms, labelFormsRecode, 
         .responseWordCount, .questionWordCount, .descriptionWordCount, 
         .hasDescription)
```

We see in the plot below that the response word counts per form and colored if a
response has a description field or not. Having a description field or not is
calculated as that a description field has a minimum one word.

```{r, fig.width=10, fig.height=7}
desc.resp.wc.plot <- description.field.wc %>% 
  ## made 'has description' column factor to modify facets.
  mutate(.hasDescription = factor(
    description.field.wc$.hasDescription, 
    levels = c(TRUE, FALSE),
    labels = c("TRUE", "FALSE"))
  )

desc.resp.wc.plot.bg <- desc.resp.wc.plot %>%
  select(labelFormsRecode, .responseWordCount)

desc.resp.wc.plot.single.stat <- desc.resp.wc.plot %>%
  group_by(.hasDescription) %>%
  summarise(Mean.rwc = mean(.responseWordCount)) %>% 
  arrange(.hasDescription)

desc.resp.wc.plot.colors <- c("#00BFC4", "#F8766D")

ppd <- ggplot(data = desc.resp.wc.plot,
              aes(x = .responseWordCount, y = labelFormsRecode, colour = .hasDescription)) +
  geom_point(data = desc.resp.wc.plot.bg,
             colour = "grey",
             alpha = 0.2) +
  geom_point(size = 3L) +
  geom_point(shape = 21, color = "black", stroke = 0.2, size = 3L) +
  geom_vline(
    data = desc.resp.wc.plot.single.stat,
    mapping = aes(xintercept = Mean.rwc, color = .hasDescription),
    linetype = "dashed"
  ) +
  facet_wrap( ~ .hasDescription) +
  scale_colour_manual(values = desc.resp.wc.plot.colors) +
  theme_ecuador1(border = TRUE) +
  guides(colour = FALSE) +
  labs(
    title = "Word count of responses depending upon the presence of description field",
    subtitle = sprintf(
      "Average response word count of questions with a description (%.2f) without any description (%.2f) field",
      dplyr::filter(desc.resp.wc.plot.single.stat, .hasDescription == TRUE)[["Mean.rwc"]],
      dplyr::filter(desc.resp.wc.plot.single.stat, .hasDescription == FALSE)[["Mean.rwc"]]
    )
  ) +
  xlab("Word count of responses") +
  ylab(NULL)

## The solution to separately color facet headings is taken from here:
## https://github.com/tidyverse/ggplot2/issues/2096#issuecomment-292971159
g <- ggplot_gtable(ggplot_build(ppd))
stripr <- grep('strip-t', g$layout$name)
k <- 1
for (i in stripr) {
  j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
  g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- desc.resp.wc.plot.colors[k]
  k <- k+1
}
grid::grid.draw(g)
```

<br>

The responses with the longest word counts are the ones with description.
Nevertheless, it is not so easy to see a clear trend that there's a correlation
between response word count and description fields. Interestingly, the form
topic *Protección_VBG* has no description fields at all in its form topics.

### Analysis of Variance

`TODO ANOVA`

### Trends 

#### Median word count of responses per partner

```{r}
narratives.wc %>% 
  group_by(partnerName) %>% 
  summarise(median = median(.responseWordCount)) %>% 
  ungroup() %>% 
  ggplot(aes(reorder(partnerName, -median), median)) +
  geom_bar(stat = "identity", width = 0.5, fill = "tomato2", color = "black") + 
  labs(
    title = "Median word count of responses per partner",
    subtitle = sprintf("The total median rate %.2f", median(narratives.wc$.responseWordCount))
  ) +
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) +
  xlab(NULL) +
  ylab(NULL)
```

#### Median word count of responses per sub partners
`TODO`

#### Median word count of responses per partner over months

```{r, include=FALSE}
narratives.med.wc_colors <- color_set_16()

narratives.med.wc <- narratives %>% 
  mutate(.responseWordCount = word_count(response)) %>%
  mutate(Month = as.Date(paste0(Month, "-01"), format = "%Y-%m-%d"))
```

```{r partner-over-time, include=FALSE}
narratives.med.wc_byPartner <- narratives.med.wc %>% 
  group_by(partnerName, Month) %>%
  summarize(median = median(.responseWordCount)) %>% 
  ungroup()

narratives.med.wc_byPartner_ts <-
  narratives.med.wc_byPartner %>%
  mutate(Month = yearmonth(Month)) %>% 
  as_tsibble(index = "Month", key = "partnerName") %>% 
  fill_gaps(median = 0, .full = TRUE)
```

```{r, fig.width=10, fig.height=10}
narratives.med.wc_byPartner_ts %>%
  ggplot(aes(Month, median, color = partnerName)) +
  geom_line() +
  geom_point() +
  geom_point(shape = 21, color = "black") +
  labs(
    title = "Median word count of responses per partner over months",
    subtitle = ""
  ) +
  xlab("Month") +
  ylab("Median word count") +
  scale_x_date(labels = date_format("%Y-%m")) +
  scale_colour_manual(values = narratives.med.wc_colors) +
  facet_wrap( ~ partnerName, scales = "free_x", ncol = 2) +
  theme_ecuador1(border = TRUE) +
  guides(colour = FALSE) +
  ## y lim is a bit more than max median value:
  ylim(0, max(narratives.med.wc_byPartner_ts$median) + 50L) +
  xlab(NULL)
```

```{r partner-subPartner-over-time, include=FALSE}
narratives.med.wc_byPartnerSubPartner <- narratives.med.wc %>% 
  group_by(partnerName, subPartnerName, Month) %>%
  summarize(median = median(.responseWordCount)) %>% 
  ungroup()

narratives.med.wc_byPartnerSubPartner_ts <-
  narratives.med.wc_byPartnerSubPartner %>%
  mutate(Month = yearmonth(Month)) %>% 
  as_tsibble(index = "Month", key = c("partnerName", "subPartnerName")) %>% 
  fill_gaps(median = 0, .full = TRUE)
```

```{r, eval=FALSE}
# TODO fix warnings
.med.wc.specific <- narratives.med.wc_byPartnerSubPartner_ts %>% 
  dplyr::filter(partnerName == c("ACNUR", "UNICEF"))

.med.wc.specific.splitted <- split(
  x = .med.wc.specific,
  f = .med.wc.specific$partnerName
)

narratives.med.wc.specific.partners <- 
  lapply(seq_along(.med.wc.specific.splitted), function(i) {
      ggplot(.med.wc.specific.splitted[[i]], aes(Month, median, color = subPartnerName)) +
      facet_wrap( ~ partnerName, scales = "free") +
      geom_line() +
      geom_point() +
      geom_point(shape = 21, color = "black") +
      xlab("Month") +
      ylab("Median word count") +
      scale_x_date(labels = scales::date_format("%Y-%m")) +
      theme_ecuador1(border = TRUE)
  })
do.call(cowplot::plot_grid, narratives.med.wc.specific.partners)
```

#### Median word count of responses per sub partners over months
`TODO`

### Correlation

`TODO`

### The regression line

We can look at multiple continuous variables in our data.

- word count of response field: the dependent variable.

- word count of question field: an independent variable.

- word count of description field: an independent variable.

Scatter plots help understand the characteristics of those variables.
However, we miss a general understanding that is the *trend line*.

```{r, plot-linear-regression}
p1 <- description.field.wc %>% 
  ggplot(aes(x = .responseWordCount, y = .questionWordCount)) +
  geom_jitter(alpha = 0.35) +
  geom_smooth(aes(colour = "linear"), method = "lm") +
  theme_ecuador1() +
  theme(legend.position = "none")
p2 <- description.field.wc %>% 
  ggplot(aes(x = .responseWordCount, y = .descriptionWordCount)) +
  geom_jitter(alpha = 0.35) +
  geom_smooth(aes(colour = "linear"), method = "lm") +
  theme_ecuador1() +
  theme(legend.position = "none")
do.call(cowplot::plot_grid, list(p1, p2))
```

The gray area around the lines shows the confidence band at the 0.95 level.
Although there's a straight slope in the linear regression line, we cannot
say that the trend line is robust because the confidence band representing the
uncertainty in the estimate is wide.

### Logistic regression

`TODO`

## Text analysis

In that section, we take text as data.

```{r child = 'analysis/text-analysis.Rmd', eval=TRUE}
```

# References

```{r, echo=FALSE, results='asis'}
bibtex::read.bib("references.bib")
```

