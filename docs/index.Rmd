---
title: "QualMiner: Exploring qualitative indicators via text mining methods"
date: "`r Sys.Date()`"
output:
  html_document:
    includes:
      in_header: assets/header.html
      after_body: assets/footer.html
    theme: cosmo
    css: assets/style.css
    highlight: pygments
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<script src="assets/script.js"></script>

<!----------------------->
<!-- global data stuff -->

```{r setup, include=FALSE}
##### ----- SOURCES ----- #####
## Header file
source(file.path("..", "R", "global-header.R"))
## Analysis related calls
source(file.path("..", "R", "analysis-methods.R"))
source(file.path("..", "R", "analysis-helpers.R"))
##### ----- PACKAGES ----- #####
## `conflicted` strategy to avoid namespace clashes.
## See https://github.com/r-lib/conflicted
library(conflicted)
conflict_prefer("filter", "dplyr")
## Libraries
library(tidyverse)
library(tidytext)
library(tsibble)
library(scales)
library(treemapify)
library(gt)
##### ----- OTHERS ----- #####
## Pre-set the bw theme for ggplot (for plots don't use any custom theme).
ggplot2::theme_set(ggplot2::theme_bw())
## knitr options
knitr::opts_chunk$set(echo = FALSE, paged.print = FALSE)
## read Data from disk:
form.table <- jsonlite::fromJSON(file.path("..", TEXT.DATA.PATH))
## (force it to be a tibble):
form.table <- tibble::as_tibble(form.table)
```

```{r FOR-INTERNAL-CHECKS, include=FALSE}
## unique record ids
unique(form.table$recordId)

## record ids and unique fields
form.table %>% 
  group_by(recordId) %>% 
  summarize(len = length(recordId)) %>% 
  arrange(desc(len))

## Code names per record
code.nms <- form.table %>% group_by(recordId) %>% select(recordId, code) %>% 
  summarize(names = list(code))
head(code.nms$names)

## Do all records have "Socio" field?
socio.fields <- sapply(seq_along(code.nms$names), function(i) "Socio" %in% code.nms$names[[i]])
all(socio.fields)

## Do all records have "direct_indirect" field?
direct_indirect.fields <- sapply(seq_along(code.nms$names), function(i) "direct_indirect" %in% code.nms$names[[i]])
all(direct_indirect.fields)
```

```{r, PARTNERS}
partners <- form.table %>% 
  group_by(recordId) %>% 
  dplyr::filter(code == "Socio") %>% 
  mutate(response = if_else(response == "FALSE", NA_character_, response)) %>% # recode FALSE
  select(recordId, partnerName, response, canton, province) %>% 
  rename(subPartnerName = response) %>% 
  mutate(subPartnerName = if_else(is.na(subPartnerName), partnerName, subPartnerName))
```

```{r NARRATIVES}
narratives <- form.table %>%
  dplyr::filter(type == "NARRATIVE") %>%
  inner_join(
    select(partners, recordId, partnerName, subPartnerName),
    by = c("partnerName", "recordId")
  ) %>%
  select(
    "folderName",
    "formName",
    "Month",
    "question",
    "response",
    "description",
    "partnerName",
    "subPartnerName",
    "province",
    "canton"
  )
```

<!----------------------->
<!-- global data stuff -->

# 1. Introduction

```{r child = 'analysis/introduction.Rmd', eval=T}
```

# 2. Descriptive statistics

```{r child = 'analysis/descriptive-statistics.Rmd', eval=T}
```

# 3. Analysis

```{r child = 'analysis/word-count-section.Rmd', eval=T}
```

# 4. Text mining & analysis

In that section, we take text as data.

```{r child = 'analysis/text-analysis.Rmd', eval=T}
```

# References

```{r, echo=FALSE, results='asis'}
bibtex::read.bib("references.bib")
```

