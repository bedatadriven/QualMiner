---
title: "QualMiner: Exploring qualitative indicators via text mining methods"
date: "`r Sys.Date()`"
output:
  html_document:
    includes:
      in_header: assets/header.html
      after_body: assets/footer.html
    theme: cosmo
    css: assets/style.css
    highlight: pygments
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<script src="assets/script.js"></script>

```{r setup, include=FALSE}
##### ----- SOURCES ----- #####
## Header file
source(file.path("..", "R", "global-header.R"))
## Analysis related calls
source(file.path("..", "R", "analysis-methods.R"))
source(file.path("..", "R", "analysis-helpers.R"))
##### ----- PACKAGES ----- #####
## `conflicted` strategy to avoid namespace clashes.
## See https://github.com/r-lib/conflicted
library(conflicted)
## Libraries
library(tidyverse)
library(tidytext)
library(tsibble)
library(scales)
library(treemapify)
library(gt)
##### ----- OTHERS ----- #####
## Pre-set the bw theme for ggplot (for plots don't use any custom theme).
ggplot2::theme_set(ggplot2::theme_bw())
## knitr options
knitr::opts_chunk$set(echo = FALSE, paged.print = FALSE, cache = TRUE)
## read Data from disk:
form.table <- jsonlite::fromJSON(file.path("..", TEXT.DATA.PATH))
## (force it to be a tibble):
form.table <- tibble::as_tibble(form.table)
```

# Introduction

```{r child = 'analysis/introduction.Rmd', eval=F}
```

```{r FOR-INTERNAL-USE, include=FALSE}
## unique record ids
unique(form.table$recordId)

## record ids and unique fields
form.table %>% 
  group_by(recordId) %>% 
  summarize(len = length(recordId)) %>% 
  arrange(desc(len))

## Code names per record
code.nms <- form.table %>% group_by(recordId) %>% select(recordId, code) %>% 
  summarize(names = list(code))
head(code.nms$names)

## Do all records have "Socio" field?
socio.fields <- sapply(seq_along(code.nms$names), function(i) "Socio" %in% code.nms$names[[i]])
all(socio.fields)

## Do all records have "direct_indirect" field?
direct_indirect.fields <- sapply(seq_along(code.nms$names), function(i) "direct_indirect" %in% code.nms$names[[i]])
all(direct_indirect.fields)
```

### Partners

They are two types of partners in the database:

+ Reporting partners: Higher level of partners reporting directly in ActivityInfo.

+ Implementing partners: Partners reporting through a reporting partner.

```{r, include=FALSE}
partners <- form.table %>% 
  group_by(recordId) %>% 
  dplyr::filter(code == "Socio") %>% 
  mutate(response = if_else(response == "FALSE", NA_character_, response)) %>% # recode FALSE
  select(recordId, partnerName, response, canton, province) %>% 
  rename(subPartnerName = response) %>% 
  mutate(subPartnerName = if_else(is.na(subPartnerName), partnerName, subPartnerName))
ppartners <- partners %>%
  group_by(partnerName) %>%
  count(partnerName, name = "freq", sort = TRUE) %>%
  ungroup() %>%
  mutate(prop = round(freq / sum(freq), 3))
```

The table below shows the count of reporting partner per each record:

+ **`r ppartners[1,"partnerName",drop=T]`** has `r xfun::n2w(ppartners[1,"freq",drop=T])`
records, 
which is `r scales::percent(ppartners[1,"prop",drop=T])`
of the total records.

+ Second, 
**`r ppartners[2,"partnerName",drop=T]`** has `r xfun::n2w(ppartners[2,"freq",drop=T])`
records, 
which is `r scales::percent(ppartners[2,"prop",drop=T])`
of the total records.

+ The most difference between percentages of the partners 
**`r ppartners[1,"partnerName",drop=T]`**
and
**`r ppartners[2,"partnerName",drop=T]`**
is
*`r paste0(floor(convolve((ppartners[1,"prop",drop=T]-ppartners[2,"prop",drop=T]), 100)), '%')`*.

<hr>

```{r}
ppartners %>%
  rename(
    `Reporting partner` = partnerName,
    `Frequency` = freq,
    `Relative frequency` = prop
  ) %>% 
  gt() %>% 
  gt_condensed_style()
```

```{r, include=FALSE}
PartnerSubPropFreq <- partners %>% 
  group_by(partnerName, subPartnerName) %>% 
  count(partnerName, subPartnerName, name = "freq", sort = TRUE) %>% 
  summarize(freq = sum(freq)) %>% 
  mutate(prop = round(freq/sum(freq), 3)) %>% 
  mutate(percent = paste0(floor(100 * freq/sum(freq)), "%"))
```

```{r, include=FALSE}
acnur.hias.part <- PartnerSubPropFreq %>% 
  dplyr::filter(partnerName %in% "ACNUR", subPartnerName %in% "HIAS")
```

<hr>

The table below shows the proportion of records entered by
partners and sub-partners.

+ *`r acnur.hias.part[,"freq",drop=T]`* out of 
*`r sum(PartnerSubPropFreq %>% dplyr::filter(partnerName %in% "ACNUR") %>% pull(freq))`* 
total responses of **ACNUR** is actually coming from **HIAS**.

+ **UNICEF** has more diversed partners in terms of reporting.
*`r PartnerSubPropFreq%>%dplyr::filter(partnerName%in% "UNICEF", subPartnerName %in% "HIAS")%>%pull(percent)`*
of responses of **UNICEF** comes from **HIAS**.
*`r PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "UNICEF", subPartnerName %in% "UNICEF")%>% pull(percent)`*
of reporting comes from the **UNICEF** itself.

+ Under **PMA**, there are *`r nrow(PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "PMA"))`* sub-partners. **HIAS** reports *`r PartnerSubPropFreq%>%dplyr::filter(partnerName %in% "PMA", subPartnerName %in% "HIAS")%>%pull("percent")`* of these records.

Those are the total numbers of reporting in all database, the numbers are not
specific to the narratives (multi-line text fields). In the next section, we
count the number of reportings done only in the narrative sections.

<hr>

```{r, echo=FALSE}
## Used parse & eval because of this issue: 
## https://github.com/rstudio/gt/issues/308
pspf.bold_groups <- glue::glue_collapse(glue::glue('
  tab_style(
    locations = cells_group(groups = "{x}"),
    style = cells_styles(text_weight = "bold")
  )
  ',
  x = unique(PartnerSubPropFreq$partnerName)
  ),
  sep = " %>%\n")
pspf.tbl <- PartnerSubPropFreq %>% 
  group_by(subPartnerName) %>% 
  arrange(desc(freq)) %>% 
  group_by(partnerName) %>% 
  rename(
    `Reporting partner` = partnerName,
    `Implementing partner` = subPartnerName,
    `Frequency` = freq,
    `Relative frequency` = prop
  ) %>% 
  select(-percent)
eval(parse(text=glue::glue('
pspf.tbl %>%
  gt() %>% 
  gt_condensed_style() %>% 
  {bolds}
', bolds = pspf.bold_groups)))
```

<hr>

```{r child = 'analysis/tabset-partner.Rmd', eval=F}
```

## Narrative data

In this section, we focus on a subset of the reports, which do particularly have
the multi-text fields, called "Narrative data" in ActivityInfo terms. Plain
saying that narrative data is multi-line text fields allowing users to enter
long texts.

```{r NARRATIVES}
narratives <- form.table %>%
  dplyr::filter(!is.na(response) & type == "NARRATIVE") %>%
  inner_join(
    select(partners, recordId, partnerName, subPartnerName),
    by = c("partnerName", "recordId")
  ) %>%
  select(
    "folderName",
    "formName",
    "Month",
    "question",
    "response",
    "description",
    "partnerName",
    "subPartnerName",
    "province",
    "canton"
  )
```

### The number of Reporting Partners and Implementing Partners recording multi-line narrative textual data

```{r}
narratives.part.count <- narratives %>% 
  group_by(partnerName, subPartnerName) %>% 
  count(partnerName, subPartnerName, name = "freq", sort=TRUE) %>% 
  summarize(freq = sum(freq)) %>% 
  mutate(prop = round(freq/sum(freq), 3)) %>% 
  mutate(percent = paste0(floor(100 * freq/sum(freq)), "%"))

## partners having multiple sub-partners
narratives.part.count.with.subPartners <- narratives.part.count %>% 
  dplyr::filter(prop != 1) %>% 
  ungroup()

## partners do not have any sub-partners reporting via them.
narratives.part.count.without.subPartners <- narratives.part.count %>% 
  dplyr::filter(prop == 1) %>% 
  ungroup()
```

As we have seen previously, Not all Reporting and Implementing Partners record
multi-line narrative textual data. For instance, the partner **PMA** has lots of
Implementing Partners reporting for the different data types (as seen in above)
but there are no narratives from them.

```{r, warning=FALSE, fig.width=7, fig.height=8}
## grouped facet wraps. Source:
## https://stackoverflow.com/questions/14840542/place-a-legend-for-each-facet-wrap-grid-in-ggplot2

plot_partners_splitted <- split(
  x = narratives.part.count.with.subPartners, 
  f = narratives.part.count.with.subPartners$partnerName
)

## bring ACNUR and UNICEF plots to the front:
plot_partners_splitted_front <- plot_partners_splitted[c(
  c("ACNUR", "UNICEF"),
  setdiff(names(plot_partners_splitted), c("ACNUR", "UNICEF"))
)]

plot_partners_list <- lapply(seq_along(plot_partners_splitted_front), function(i) {
  ggplot(plot_partners_splitted_front[[i]], aes(x = partnerName, y = prop)) +
    geom_bar(aes(fill = reorder(subPartnerName,-prop)), position = "dodge", stat =
               "identity", color = "black") +
    facet_wrap(~ partnerName, scales = "free") +
    geom_label(
      aes(
        label = percent,
        group = reorder(subPartnerName,-prop),
        vjust = 0.65
      ),
      position = position_dodge(width = 1),
      label.size = 0.35
    ) +
    ylim(0, 1) + 
    xlab(NULL) +
    ylab(NULL) +
    theme_ecuador1(border = TRUE) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      legend.title = element_blank(),
      legend.position = "bottom"
    ) +
    scale_fill_brewer(palette = eval(quote(brewer_diverging_color_names()[i])))
})

## "cowplot" is civilized version of 'gridExtra'.
do.call(cowplot::plot_grid, plot_partners_list)
```

+ *`r subset(narratives.part.count.with.subPartners, partnerName == "ACNUR" & subPartnerName == "HIAS", "percent", drop = T)`*
of the narrative records are
entered by the implementing partner **HIAS** reported via **ACNUR**.
Only
*`r subset(narratives.part.count.with.subPartners, partnerName == "ACNUR" & subPartnerName == "ACNUR", "percent", drop = T)`*
of the narrative records are entered by **ACNUR** itself.

+ Also **HIAS** enters *`r subset(narratives.part.count.with.subPartners, partnerName == "UNICEF" & subPartnerName == "HIAS", "percent", drop = T)`* of the narrative records via **UNICEF**.

+ The rest of the reporting partners do not have implementing partners, they do
the all implementation themselves:
*`r paste(unique(narratives.part.count.without.subPartners$partnerName), collapse = ", ")`*.

***

### The number of cantons and provinces recording narrative data

```{r, include = FALSE}
locations <- narratives %>% 
  count(province, canton, name = "freq") %>%
  group_by(province, canton) %>% 
  summarize(freq = sum(freq)) %>%
  mutate(canton.prop = round(freq/sum(freq), 3)) %>% 
  mutate(canton.percent = paste0(floor(100 * freq/sum(freq)), "%")) %>% 
  ungroup() %>% 
  mutate(province.prop = round(freq/sum(freq), 3)) %>% 
  mutate(province.percent = paste0(floor(100 * freq/sum(freq)), "%")) %>% 
  arrange(desc(freq))
```

```{r canton-locations-tbl}
## Used parse & eval because of this issue: 
## https://github.com/rstudio/gt/issues/308
lcts.bold_groups <- glue::glue_collapse(glue::glue('
  tab_style(
    locations = cells_group(groups = "{x}"),
    style = cells_styles(text_weight = "bold")
  )
  ', 
  x = unique(locations$province)
),
sep = " %>%\n")
lcts.tbl <- locations %>%
  select(province, canton, freq, canton.prop, province.prop) %>%
  group_by(province) %>% 
  arrange(desc(freq)) %>% 
  rename(
    `Canton` = canton,
    `Frequency` = freq,
    `Relative frequency (canton)` = canton.prop,
    `Relative frequency (province)` = province.prop
  )
eval(parse(text=glue::glue('
lcts.tbl %>% 
  gt() %>% 
  tab_header(
    title = "Canton and provinces",
    subtitle = "The number of reports in the multi-text (narrative) fields"
  ) %>% 
  gt_condensed_style() %>% 
  {bolds}
', bolds = lcts.bold_groups)))
```

<br>

```{r child = 'analysis/treemap-canton.Rmd', eval=F}
```

# Analysis

## Recode form label names

First of all, we shorten the names and therefore re code form topics because they appear to be
too long and disarray the plots. The *re coded table* below provides a lookup table
for the form labels.

```{r recode-table}
narratives <- narratives %>% 
  mutate(
    formNameRecode = recode(
      formName,
      "Agua, saneamiento e higiene" = "Agua",
      "Alojamiento Temporal" = "Alojamiento",
      "Necesidades básicas/Otro" = "Necesidades",
      "Manejo de la información y entrega directa de la información a la población" = "Poblacion",
      "Manejo de la información para socios y análisis de las necesidades" = "Socios",
      "Protección_VBG" = "VBG",
      "Trata_y_tráfico" = "Trafico",
      "Acceso_a_educación" = "Educacion",
      "Acceso a vivienda y hábitat dignos en comunidades receptoras" = "Habitat",
      "Medios de vida y formación técnico-profesional" = "Tecnico",
      "Cohesión_social" = "SocialCohesion",
      "Apoyo Educacional a Comunidades Receptoras" = "Educacional",
      "Asistencia técnica para VBG-SSR" = "VBG_SSR",
      "Asistencia técnica para protección/gestión de fronteras" = "Fronteras",
      "Asistencia técnica para gestion de la informacion y coordinacion" = "Coordinacion",
      "Asistencia técnica para el sector laboral" = "SectorLaboral",
      "Asistencia técnica para protección" = "Proteccion",
      "Asistencia técnica para protección de la infancia" = "ProteccionInfancia",
      "Protección_LGBTI" = "LGBTI"
    )
  )

recode_tbl <- narratives %>%
  select(folderName, formName, formNameRecode) %>% 
  arrange(folderName) %>% 
  distinct()

recode_tbl %>% 
  group_by(folderName) %>% 
  gt() %>% 
  gt_condensed_style() %>% 
  tab_footnote(
    footnote = md("*Recoding only some long label forms, shorter names can stay as such (e.g. 'Salud')*"),
    locations = cells_column_labels(
      columns = vars(formNameRecode)
    )
  )
```

```{r child = 'analysis/word-count-section.Rmd', eval=F}
```

## Text analysis

In that section, we take text as data.

```{r child = 'analysis/text-analysis.Rmd', eval=T}
```

# References

```{r, echo=FALSE, results='asis'}
bibtex::read.bib("references.bib")
```

