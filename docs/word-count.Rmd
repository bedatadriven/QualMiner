# Word count {-}

One issue with the nature of the questions is that they are only unique in a
form. These questions can be distributed across multiple forms. The questions
sharing the same name will have different meanings. For instance, the question
"*Cualitativo*" from the form "*Salud*" should imply different thing than the
question "*Cualitativo*" from the form "*Protecci√≥n_VBG*".

In order to solve this kind of problem:

+ We can combine question with the form and also its folder label. There we can
achieve a unique name for each question.

+ Another thing to resolve this would be doing analysis to move the analysis up
to form level. In this file, we did both, therefore the analysis shown as below:

Count of responses per topic/question (note that missing entries `NA`s are
removed):
```{r count-response}
narratives.wc <- narratives %>%
  dplyr::filter(!is.na(response)) %>% ## remove NAs
  mutate(.responseWordCount = word_count(response)) %>%
  mutate(.questionWordCount = word_count(question)) %>%
  mutate(.descriptionWordCount = word_count(description)) %>%
  group_by(formName) %>%
  ungroup()

head(narratives.wc) %>% 
  mutate(response = strtrim(response, 15)) %>% 
  mutate(description = strtrim(description, 15)) %>% 
  gt() %>% 
  gt_condensed_style()
```

It's also a good practice to see the number of questions. For example, one
question has two responses, therefore they're short. 

<hr>

The standard deviation is a single number statistics to show the *measure
of spread* in data.

```{r sd-form-topic-table}
rwc.sd <- narratives.wc %>% 
  group_by(formNameRecode) %>% 
  summarize(SD = sd(.responseWordCount))

rwc.sd %>% 
  gt() %>%
  fmt_number(
    columns = vars(SD),
    decimals = 2,
    use_seps = T
  ) %>%
  fmt_missing(
    columns = vars(SD),
    missing_text = md("*NA*")
  ) %>%
  tab_header(
    title = "Deviation of response word counts per form topic",
    subtitle = md("Measure the spread with *standard deviation*")
  )
```

<br>

In the plot above, the box plot of form topics and response word counts based on
the raw data, the outliers are shown in orange color. Outliers are the points
placed outside the whiskers, which is the long line, of the boxplot.

## Distribution of word counts {-}

```{r, fig.align='center'}
inspect_num(narratives.wc, breaks = 10) %>%
  show_plot()
```

There's a lot of variation in response word count. We need to know what are those responses with a word count of 1. Or better to eliminate the responses which has less than 5 words (an arbitrary number to filter).

<hr>

## Median word count of responses per form name {-}

*A caveat:* Reducing multiple values down to a single value should be avoided in
the early stages of the analysis because reducing hides a lot e.g. a bar chart
showing average the word count per partner. Some partners may write longer than
others, because:

1. They *actually* write longer than other partners.

2. The questions they answered require short answers.

```{r, fig.align='center'}
x1<-narratives.wc %>% 
  dplyr::filter(formNameRecode != "Salud") %>% 
  group_by(formNameRecode) %>% 
  summarise(median = median(.responseWordCount)) %>% 
  ungroup()

x1 %>%   
  ggplot(aes(reorder(formNameRecode, -median), median)) +
  geom_bar(stat = "identity", width = 0.5, fill = "tomato2", color = "black") + 
  labs(
    title = "Median word count of responses per form name",
    subtitle = sprintf("The total median rate %.2f", median(x1$.responseWordCount))
  ) +
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) +
  xlab(NULL) +
  ylab(NULL)
```

Here above we remove `Salud` form because it has only 
`r nrow(narratives.wc[narratives.wc$formNameRecode=="Salud",])` 
records and skews the data.

## Median word count of responses per partner {-}

```{r, fig.align='center'}
narratives.wc %>% 
  group_by(partnerName) %>% 
  summarise(median = median(.responseWordCount)) %>% 
  ungroup() %>% 
  ggplot(aes(reorder(partnerName, -median), median)) +
  geom_bar(stat = "identity", width = 0.5, fill = "tomato2", color = "black") + 
  labs(
    title = "Median word count of responses per partner",
    subtitle = sprintf("The total median rate %.2f", median(narratives.wc$.responseWordCount))
  ) +
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) +
  xlab(NULL) +
  ylab(NULL)
```

## Median word count of responses per specific reporting partners {-}

```{r, fig.align='center'}
narratives.wc.median.specific.partners <- narratives.wc %>% 
  group_by(partnerName, subPartnerName) %>% 
  summarise(median = median(.responseWordCount)) %>% 
  dplyr::filter(partnerName %in% c("ACNUR", "UNICEF") | subPartnerName %in% "HIAS")

narratives.wc.median.specific.partners_splitted <- split(
  x = narratives.wc.median.specific.partners, 
  f = narratives.wc.median.specific.partners$partnerName
)

narratives.wc.median.specific.partners_splitted_list <- 
  lapply(seq_along(narratives.wc.median.specific.partners_splitted), function(i) {
    ggplot(narratives.wc.median.specific.partners_splitted[[i]], aes(x = partnerName, y = median)) +
      geom_bar(aes(fill = reorder(subPartnerName,-median)), position = "dodge", stat =
                 "identity", color = "black") +
      facet_wrap(~ partnerName, scales = "free") +
      #ylim(0, 1) + 
      xlab(NULL) +
      ylab(NULL) +
      theme_ecuador1(border = TRUE) +
      theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        legend.position = "bottom"
      ) +
      scale_fill_brewer(palette = eval(quote(brewer_diverging_color_names()[i])))
  })

## "cowplot" is civilized version of 'gridExtra'.
do.call(cowplot::plot_grid, narratives.wc.median.specific.partners_splitted_list)
```

## Median word count of responses per partner over months {-}

```{r, include=FALSE}
narratives.med.wc_colors <- color_set_16()

narratives.med.wc <- narratives %>% 
  dplyr::filter(!is.na(response)) %>% 
  mutate(.responseWordCount = word_count(response)) %>%
  mutate(Month = as.Date(paste0(Month, "-01"), format = "%Y-%m-%d"))
```

```{r partner-over-time, include=FALSE}
narratives.med.wc_byPartner <- narratives.med.wc %>% 
  group_by(partnerName, Month) %>%
  summarize(median = median(.responseWordCount)) %>% 
  ungroup()

narratives.med.wc_byPartner_ts <-
  narratives.med.wc_byPartner %>%
  mutate(Month = yearmonth(Month)) %>% 
  as_tsibble(index = "Month", key = "partnerName") %>% 
  fill_gaps(median = 0, .full = TRUE)
```

```{r, fig.width=10, fig.height=10, fig.align='center'}
narratives.med.wc_byPartner_ts %>%
  ggplot(aes(Month, median, color = partnerName)) +
  geom_line() +
  geom_point() +
  geom_point(shape = 21, color = "black") +
  labs(
    title = "Median word count of responses per partner over months",
    subtitle = ""
  ) +
  xlab("Month") +
  ylab("Median word count") +
  scale_x_date(labels = date_format("%Y-%m")) +
  scale_colour_manual(values = narratives.med.wc_colors) +
  facet_wrap( ~ partnerName, scales = "free_x", ncol = 2) +
  theme_ecuador1(border = TRUE) +
  guides(colour = FALSE) +
  ## y lim is a bit more than max median value:
  ylim(0, max(narratives.med.wc_byPartner_ts$median) + 50L) +
  xlab(NULL)
```

```{r partner-subPartner-over-time, include=FALSE}
narratives.med.wc_byPartnerSubPartner <- narratives.med.wc %>% 
  group_by(partnerName, subPartnerName, Month) %>%
  summarize(median = median(.responseWordCount)) %>% 
  ungroup()

narratives.med.wc_byPartnerSubPartner_ts <-
  narratives.med.wc_byPartnerSubPartner %>%
  mutate(Month = yearmonth(Month)) %>% 
  as_tsibble(index = "Month", key = c("partnerName", "subPartnerName")) %>% 
  fill_gaps(median = 0, .full = TRUE)
```

## Median word count of responses per specific reporting partners over months {-}

```{r, specific-reporting-partners-over-months, fig.align='center'}
.med.wc.specific <- narratives.med.wc_byPartnerSubPartner_ts %>% 
  dplyr::filter(partnerName %in% c("ACNUR", "UNICEF") | subPartnerName %in% "HIAS")

.med.wc.specific.splitted <- split(
  x = .med.wc.specific,
  f = .med.wc.specific$partnerName
)

narratives.med.wc.specific.partners <- 
  lapply(seq_along(.med.wc.specific.splitted), function(i) {
      ggplot(.med.wc.specific.splitted[[i]], aes(Month, median, color = subPartnerName)) +
      facet_wrap( ~ partnerName, scales = "free") +
      geom_line() +
      geom_point() +
      geom_point(shape = 21, color = "black") +
      xlab("Month") +
      ylab("Median word count") +
      scale_x_date(labels = scales::date_format("%Y-%m")) +
      theme_ecuador1(border = TRUE) +
      theme(legend.title = element_blank()) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1.1))
  })
## An hacky way to add some space between cowplots:
## https://github.com/wilkelab/cowplot/issues/11#issuecomment-235643412
narratives.med.wc.specific.partners[[3]] <- narratives.med.wc.specific.partners[[2]]
narratives.med.wc.specific.partners[[2]] <- list(NULL)
do.call(function(...) cowplot::plot_grid(..., nrow = 1, rel_widths = c(1, 0.1, 1)), narratives.med.wc.specific.partners)
```


## The Description field {-}

Some questions have the description field giving extra details about the
questions.

Do some questions with the extra description field have better *response
quality* than the questions which do not have it?

Looking at the table containing form name, question, description and so on:

```{r, table1}
description.field.wc <- narratives.wc %>% 
  mutate(.hasDescription = ifelse(is.na(description), FALSE, TRUE)) %>% 
  select(formName, formNameRecode, 
         .responseWordCount, .questionWordCount, .descriptionWordCount, 
         .hasDescription)
```

We see in the plot below that the response word counts per form and colored if a
response has a description field or not. Having a description field or not is
calculated as that a description field has a minimum one word.

```{r, fig.width=10, fig.height=6}
desc.resp.wc.plot <- description.field.wc %>% 
  ## made 'has description' column factor to modify facets.
  mutate(.hasDescription = factor(
    description.field.wc$.hasDescription, 
    levels = c(TRUE, FALSE),
    labels = c("TRUE", "FALSE"))
  )

desc.resp.wc.plot.bg <- desc.resp.wc.plot %>%
  select(formNameRecode, .responseWordCount)

desc.resp.wc.plot.single.stat <- desc.resp.wc.plot %>%
  group_by(.hasDescription) %>%
  summarise(Mean.rwc = mean(.responseWordCount)) %>% 
  arrange(.hasDescription)

desc.resp.wc.plot.colors <- c("#00BFC4", "#F8766D")

ppd <- ggplot(data = desc.resp.wc.plot,
              aes(x = .responseWordCount, y = formNameRecode, colour = .hasDescription)) +
  geom_point(data = desc.resp.wc.plot.bg,
             colour = "grey",
             alpha = 0.2) +
  geom_point(size = 3L) +
  geom_point(shape = 21, color = "black", stroke = 0.2, size = 3L) +
  geom_vline(
    data = desc.resp.wc.plot.single.stat,
    mapping = aes(xintercept = Mean.rwc, color = .hasDescription),
    linetype = "dashed"
  ) +
  facet_wrap( ~ .hasDescription) +
  scale_colour_manual(values = desc.resp.wc.plot.colors) +
  theme_ecuador1(border = TRUE) +
  guides(colour = FALSE) +
  labs(
    title = "Word count of responses depending upon the presence of description field",
    subtitle = sprintf(
      "Average response word count of questions with a description (%.2f) without any description (%.2f) field",
      dplyr::filter(desc.resp.wc.plot.single.stat, .hasDescription == TRUE)[["Mean.rwc"]],
      dplyr::filter(desc.resp.wc.plot.single.stat, .hasDescription == FALSE)[["Mean.rwc"]]
    )
  ) +
  xlab("Word count of responses") +
  ylab(NULL)

## The solution to separately color facet headings is taken from here:
## https://github.com/tidyverse/ggplot2/issues/2096#issuecomment-292971159
g <- ggplot_gtable(ggplot_build(ppd))
stripr <- grep('strip-t', g$layout$name)
k <- 1
for (i in stripr) {
  j <- which(grepl('rect', g$grobs[[i]]$grobs[[1]]$childrenOrder))
  g$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- desc.resp.wc.plot.colors[k]
  k <- k+1
}
grid::grid.draw(g)
```

<br>

The responses with the longest word counts are the ones with description.
Nevertheless, it is not so easy to see a clear trend that there's a correlation
between response word count and description fields. Interestingly, the form
topic *Protecci√≥n_VBG* has no description fields at all in its form topics.

## Analysis of Variance {-}

`TODO ANOVA`

## Correlation {-}

The correlation between the word count of different fields in the
*ActivityInfo*:

```{r}
## Source:
## http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization

## Subset the numerical columns:
cordata <- narratives.wc %>% 
  select(.responseWordCount, .questionWordCount, .descriptionWordCount) %>% 
  dplyr::filter(.responseWordCount > 1)

## Compute the correlation matrix:
cormat <- round(cor(cordata), 2)
```

```{r, cor-table}
mmy::std_rownames(as.data.frame(cormat)) %>%
  gt() %>% 
  #gt_condensed_style() %>% 
  cols_label(
    .rowname = ""
  )
```

+ `r paste0(round(100*table(narratives.wc$.responseWordCount)[[1]]/length(narratives.wc$.responseWordCount),2),"%")`
of the words in the response field have only `1` words. And those words were
just not important (as they are 
`r narratives.wc %>% dplyr::filter(.responseWordCount == 1 & !is.na(response)) %>% select(response) %>% distinct() %>% pull()`).

```{r, fig.align='center'}
inspect_cor(narratives.wc) %>% 
  show_plot()
```

`TODO`

## The regression lines {-}

We can look at multiple continuous variables in our data.

- word count of response field: `response.wc`

- word count of question field: `question.wc`

- word count of description field: `description.wc`

Given this data, the model formula showing dependent and independent variables
can be as follows:

$ response.wc \sim question.wc $

$ response.wc \sim question.wc + description.wc $

In that sense the *word count of response* field is the dependent variable and
*word count of question* and *word count of description* fields are the
independent variables in the regression.

Thus, we expect to have more word count in question and description fields to
have a positive effect on the word count of response field.

Scatter plots help understand the characteristics of those variables.
However, we miss a general understanding that is the *trend line*.

```{r plot-linear-regression, fig.align='center'}
p1 <- description.field.wc %>% 
  ggplot(aes(x = .responseWordCount, y = .questionWordCount)) +
  geom_jitter(alpha = 0.35) +
  geom_smooth(aes(colour = "linear"), method = "lm") +
  theme_ecuador1() +
  theme(legend.position = "none")

p2 <- description.field.wc %>% 
  ggplot(aes(x = .responseWordCount, y = .descriptionWordCount)) +
  geom_jitter(alpha = 0.35) +
  geom_smooth(aes(colour = "linear"), method = "lm") +
  theme_ecuador1() +
  theme(legend.position = "none")

do.call(cowplot::plot_grid, list(p1, p2))
```

The gray area around the lines shows the confidence band at the *0.95* level.
Although there's a straight slope in the linear regression line, we cannot
say that the trend line is robust because the confidence band representing the
uncertainty in the estimate is wide.

## Logistic regression {-}

`TODO`
In fact, it is called the *binomial logistic regression*.
When one of the independent variables is dichotomous (having two categories), `...`

## Hypothesis testing {-}

We do the hypothesis testing based on the assumptions we have.

$ H_0 $ : More word count in questions results in more word count in responses.

`TODO`

